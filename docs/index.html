<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ åœ°ç‰¢å‹‡è€…</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        h1 { margin: 10px 0; font-size: 24px; text-shadow: 2px 2px #000; }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #555;
        }
        canvas {
            display: block;
            background-color: #1a1a1a;
            image-rendering: pixelated; /* ä¿æŒåƒç´ æ¸…æ™° */
        }
        #ui {
            width: 600px;
            display: flex;
            justify-content: space-between;
            background: #333;
            padding: 10px;
            box-sizing: border-box;
            border: 4px solid #555;
            border-top: none;
            font-size: 18px;
        }
        .stat { color: #ddd; }
        #log {
            font-size: 14px;
            color: #aaa;
            margin-top: 10px;
            height: 20px;
        }
        .controls {
            margin-top: 15px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>

    <h1>ğŸ° åƒç´ åœ°ç‰¢å‹‡è€…</h1>
    
    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>

    <div id="ui">
        <span class="stat" id="level-display">LV: 1</span>
        <span class="stat" id="hp-display">HP: 100/100</span>
        <span class="stat" id="xp-display">XP: 0/50</span>
        <span class="stat" id="floor-display">B1F</span>
    </div>
    <div id="log">æ­¡è¿ä¾†åˆ°åœ°ç‰¢...</div>
    <div class="controls">æ§åˆ¶: WASD æˆ– æ–¹å‘éµç§»å‹•/æ”»æ“Š | ç©ºç™½éµ: è·³éå›åˆ</div>

<script>
    // --- éŠæˆ²è¨­å®š ---
    const TILE_SIZE = 40; // æ ¼å­å¤§å°
    const COLS = 15;
    const ROWS = 10;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- éŠæˆ²ç‹€æ…‹ ---
    let player = {
        x: 1,
        y: 1,
        hp: 100,
        maxHp: 100,
        level: 1,
        xp: 0,
        nextLevelXp: 50,
        damage: 10,
        color: '#4a90e2' // è—è‰²å‹‡è€…
    };

    let floor = 1;
    let enemies = [];
    let messages = [];
    
    // ç°¡å–®çš„éŸ³æ•ˆ (ä½¿ç”¨ Web Audio API æˆ–æ˜¯ç°¡å–®çš„ beep æ¨¡æ“¬ï¼Œé€™è£¡åƒ…ä½œè¦–è¦ºæç¤º)
    
    function log(msg) {
        document.getElementById('log').innerText = msg;
    }

    function updateUI() {
        document.getElementById('level-display').innerText = `LV: ${player.level}`;
        document.getElementById('hp-display').innerText = `HP: ${player.hp}/${player.maxHp}`;
        document.getElementById('xp-display').innerText = `XP: ${player.xp}/${player.nextLevelXp}`;
        document.getElementById('floor-display').innerText = `B${floor}F`;
    }

    // --- ç”Ÿæˆåœ°åœ–èˆ‡æ•µäºº ---
    function spawnEnemies() {
        enemies = [];
        let count = 3 + Math.floor(floor * 0.5); // éš¨å±¤æ•¸å¢åŠ æ•µäºº
        for (let i = 0; i < count; i++) {
            let ex, ey;
            do {
                ex = Math.floor(Math.random() * COLS);
                ey = Math.floor(Math.random() * ROWS);
            } while ((ex === player.x && ey === player.y) || enemies.some(e => e.x === ex && e.y === ey));

            enemies.push({
                x: ex,
                y: ey,
                hp: 20 + (floor * 5),
                maxHp: 20 + (floor * 5),
                damage: 5 + floor,
                color: '#e74c3c', // ç´…è‰²å²èŠå§†
                type: 'å²èŠå§†'
            });
        }
    }

    // --- ç¹ªåœ–ç³»çµ± ---
    function drawRect(x, y, color, border = false) {
        ctx.fillStyle = color;
        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        if (border) {
            ctx.strokeStyle = "rgba(0,0,0,0.3)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
    }

    function drawPixelArt(x, y, type) {
        // ç°¡å–®çš„ Canvas ç¹ªåœ–æ¨¡æ“¬åƒç´ åœ–
        const cx = x * TILE_SIZE;
        const cy = y * TILE_SIZE;
        const size = TILE_SIZE;

        if (type === 'player') {
            // å‹‡è€…é ­åƒ
            ctx.fillStyle = player.color;
            ctx.fillRect(cx + 5, cy + 5, size - 10, size - 10);
            // çœ¼ç›
            ctx.fillStyle = "white";
            ctx.fillRect(cx + 10, cy + 12, 6, 6);
            ctx.fillRect(cx + 24, cy + 12, 6, 6);
            ctx.fillStyle = "black";
            ctx.fillRect(cx + 12, cy + 14, 2, 2);
            ctx.fillRect(cx + 26, cy + 14, 2, 2);
        } else if (type === 'enemy') {
            // å²èŠå§†
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(cx + 8, cy + 15, size - 16, size - 20); // èº«é«”
            ctx.fillRect(cx + 12, cy + 10, size - 24, 10); // é ­é ‚
            // çœ¼ç›
            ctx.fillStyle = "yellow";
            ctx.fillRect(cx + 12, cy + 18, 4, 4);
            ctx.fillRect(cx + 24, cy + 18, 4, 4);
        }
    }

    function draw() {
        // æ¸…ç©ºèƒŒæ™¯
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç•«åœ°æ¿ç¶²æ ¼
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        for (let x = 0; x < COLS; x++) {
            for (let y = 0; y < ROWS; y++) {
                ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        // ç•«æ•µäºº
        enemies.forEach(e => {
            drawPixelArt(e.x, e.y, 'enemy');
            // è¡€æ¢
            const hpPercent = e.hp / e.maxHp;
            ctx.fillStyle = 'red';
            ctx.fillRect(e.x * TILE_SIZE + 5, e.y * TILE_SIZE - 5, 30, 4);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(e.x * TILE_SIZE + 5, e.y * TILE_SIZE - 5, 30 * hpPercent, 4);
        });

        // ç•«ç©å®¶
        drawPixelArt(player.x, player.y, 'player');
    }

    // --- éŠæˆ²é‚è¼¯ ---
    function movePlayer(dx, dy) {
        if (player.hp <= 0) return;

        const newX = player.x + dx;
        const newY = player.y + dy;

        // é‚Šç•Œæª¢æŸ¥
        if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) return;

        // æ•µäººç¢°æ’æª¢æŸ¥
        const targetEnemyIndex = enemies.findIndex(e => e.x === newX && e.y === newY);

        if (targetEnemyIndex !== -1) {
            // æ”»æ“Šæ•µäºº
            const enemy = enemies[targetEnemyIndex];
            const dmg = Math.floor(player.damage * (1 + Math.random() * 0.2)); // æµ®å‹•å‚·å®³
            enemy.hp -= dmg;
            log(`ä½ æ”»æ“Šå²èŠå§†ï¼Œé€ æˆ ${dmg} é»å‚·å®³ï¼`);
            
            // éœ‡å‹•æ•ˆæœ
            canvas.style.transform = `translate(${Math.random()*4-2}px, ${Math.random()*4-2}px)`;
            setTimeout(() => canvas.style.transform = 'none', 50);

            if (enemy.hp <= 0) {
                enemies.splice(targetEnemyIndex, 1);
                gainXp(15 + floor * 5);
                log("å²èŠå§†è¢«æ“Šæ•—äº†ï¼");
                
                // æª¢æŸ¥æ˜¯å¦ä¸‹ä¸€å±¤
                if (enemies.length === 0) {
                    setTimeout(nextFloor, 500);
                }
            }
        } else {
            // ç§»å‹•
            player.x = newX;
            player.y = newY;
        }

        enemyTurn();
        draw();
        updateUI();
    }

    function gainXp(amount) {
        player.xp += amount;
        if (player.xp >= player.nextLevelXp) {
            player.level++;
            player.xp -= player.nextLevelXp;
            player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
            player.maxHp += 20;
            player.hp = player.maxHp;
            player.damage += 5;
            log(`å‡ç´šäº†ï¼ç›®å‰ç­‰ç´š ${player.level}`);
        }
    }

    function enemyTurn() {
        enemies.forEach(e => {
            if (Math.random() < 0.3) return; // æ•µäººæœ‰æ™‚å€™æœƒç™¼å‘†

            const dx = player.x - e.x;
            const dy = player.y - e.y;
            let moveX = 0;
            let moveY = 0;

            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? 1 : -1;
            } else {
                moveY = dy > 0 ? 1 : -1;
            }

            // æª¢æŸ¥ç›®æ¨™ä½ç½®æ˜¯å¦æœ‰å…¶ä»–æ•µäºº
            if (!enemies.some(other => other !== e && other.x === e.x + moveX && other.y === e.y + moveY)) {
                if (e.x + moveX === player.x && e.y + moveY === player.y) {
                    // æ”»æ“Šç©å®¶
                    const dmg = Math.max(1, e.damage - Math.floor(player.level / 2));
                    player.hp -= dmg;
                    log(`å²èŠå§†æ”»æ“Šä½ ï¼Œå—åˆ° ${dmg} é»å‚·å®³ï¼`);
                    if (player.hp <= 0) {
                        log("ä½ å·²ç¶“æ­»äº¡... æŒ‰ F5 é‡æ–°é–‹å§‹");
                        player.color = '#555'; // è®Šç°è‰²
                    }
                } else {
                    e.x += moveX;
                    e.y += moveY;
                }
            }
        });
    }

    function nextFloor() {
        floor++;
        log(`é€²å…¥åœ°ä¸‹ ${floor} å±¤...`);
        player.x = 0;
        player.y = 0;
        player.hp = Math.min(player.hp + 20, player.maxHp); // å›å¾©ä¸€é»è¡€
        spawnEnemies();
        draw();
        updateUI();
    }

    // --- è¼¸å…¥æ§åˆ¶ ---
    window.addEventListener('keydown', (e) => {
        if (player.hp <= 0) return;
        
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                movePlayer(0, -1);
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                movePlayer(0, 1);
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                movePlayer(-1, 0);
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                movePlayer(1, 0);
                break;
            case ' ':
                enemyTurn(); // ç­‰å¾…ä¸€å›åˆ
                draw();
                updateUI();
                break;
        }
    });

    // --- å•Ÿå‹•éŠæˆ² ---
    spawnEnemies();
    draw();
    updateUI();

</script>
</body>
</html>
